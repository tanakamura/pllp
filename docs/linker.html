<html>
<head>
  <meta charset="utf-8"/>
  <title> リンカ </title>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>

<p> <a href="index.html"> 戻る </a> </p>

<h2> <a href="asm_language.html"> リンカ </a> </h2>

  <p>
    ついに、リンカの説明をするときが来た。
  </p>

  <p>
    ここに至るまでに、何度「リンカのところで説明する」と書いただろうか？
    ここまで読んできた人ならば、
    リンカというものが、なにやら色々やっているんだな、というのはわかってきたのではないかと思う。
  </p>

  <p>
    筆者が常々思っていることのひとつに、「C言語に関する書籍は、リンカの説明をおざなりにしすぎだ」というのがある。
  </p>
  <p>
    多くのC言語の書籍は、
  </p>
  <ol>
    <li> コンパイラがソースコードをアセンブリコードに変換します </li>
    <li> アセンブラがアセンブリコードを機械語に変換します </li>
    <li> リンカが機械語をリンクして実行ファイルが作られます </li>
  </ol>

  <p>
    と、いう解説がなされがちである。この説明を見たら、多くの人が、「え、リンクってなんですか？」と、思うに違いない。
  </p>
  <p>
    アセンブラには、「人間が読めるニーモニックを、機械が読める機械語に変換する」みたいな、最低限の説明が付くものの、
    リンカの説明は「リンクをします」のひとことだけである！
  </p>

  <p>
    ここでは、いつも雑な説明をされがちな、リンカについて説明をしていきたいと思う。
  </p>

  <p>
    C言語の言語仕様には、明示的にリンクについて書かれてはいないものの、
    extern 指定子など、言語仕様の一部に、リンクの処理を無視して説明できない仕様を含んでいるのは間違いない。
    リンクについて知れば、C言語への理解も、もう一歩深まるだろう。
  </p>

  <h3> コンパイラドライバ、libc、スタートアップルーチン </h3>
<p> リンカの説明前にいくつか必要な説明をしておこう。 </p>

<p> <a href="link/main.s"> link/main.s </a> </p>

<pre>
	.globl	main
main:
	ret
</pre>

<p>
  このプログラムを gcc -static でコンパイルして、objdump -d で逆アセンブルを確認してほしい。
  main 関数に含まれる命令は1個しかないのに、実際の実行ファイルには大量の命令が含まれていることが確認できるはずだ。
  この大量の命令は、<em>libc</em>と呼ばれるライブラリ等から来る命令だ。
</p>

<p>
  <em> libc </em> は、C言語の仕様を満たすために定義された関数、データを含むライブラリだ。
  Cを書いたことがある人なら、printf、malloc などの関数を使ったことがあるだろう。
  printf関数やmalloc関数はこの、libc の中に実装されている。
  libc には、いくつか種類があって、x86_64 の Linux では、glibc(The GNU C Library) と呼ばれるlibcが使われている。
  Windows では、msvcrt(Microsoft Visual Studio C Runtime か?)と呼ばれるlibcが使われることが多い。
</p>

<p>
  実際には、Linux上のgccでビルドした場合、libcの他に、<em>スタートアップルーチン</em>と、<em>libgcc</em> がリンクされる。
  これらの詳細については、またあとでlibcのところで説明しよう。
</p>

<p>
  ここで、"gcc" というコマンドが、.s を変換するだけでなく、libcとのリンクも行っている点に注意しよう。
  ついでに、これまでも "gcc" というコマンドを使って、アセンブリ(.s) を実行ファイル(a.out) に変換していたことを思い出して欲しい。
</p>

<p>
  "gcc"というコマンドは、その名前に反して、*Cコンパイラではない*！
  "gcc"は、<em>コンパイラドライバ (compiler driver)</em>と呼ばれるプログラムで、
  ソースコードファイルを実行ファイルに変換する時に必要なコマンドを良い感じに呼び出してくれるツールだ。
</p>

<p>
  <em>コンパイラドライバ</em>の挙動は、仕様もなく、ドキュメンテーションもされておらず、OS、コンパイラ毎に挙動がマチマチで、
  「良い感じに」処理してくれるとしか言いようのない動作をする。
</p>

<p>
  Linux 上の gcc コンパイラドライバは、大体以下のような動作をする。(実際には色々オプションによって挙動変わるので、もう少し複雑だ。ちなみに、clang はこの動作をかなりの精度で再現する)
</p>

<ul>
  <li> 引数に .c というファイルが渡された場合は、gcc に含まれる cc1 (これが本物のCコンパイラのコマンドだ) を呼び出して .c を .s に変換する </li>
  <li> 引数に .cpp, .f, .java, など、各種ソースが渡された場合は、.c と同様に対応するコンパイラを呼び出して .s に変換する </li>
  <li> 引数に -S が付いていない場合は、as (アセンブラ)を呼び出して cc1 などが出力した .s、引数に渡された.s を .o に変換する (-S が付けられた場合は、.oに変換せず、.s を出力する) </li>
  <li> 引数に -c が付いていない場合は、ld (リンカ)を呼び出して引数に渡されたソースを.oに変換したものと libc、-l オプションで渡された追加のライブラリをリンクする (-c が付けられた場合は、リンクしないで、.o を出力する) </li>
</ul>

<p>
  ld(リンカ) は gcc から呼ばれるときは、collect2 というラッパーを経由して呼ばれるが、
  現代ではLTO(Link Time Optimization) を使わない場合はcollect2 = ld と解釈してもらって構わない。(TODO : collect2 が必要な理由を調べる)。
</p>

<p>
  gcc に、-v を付けると、実際に背後でどういうコマンドが実行されるか確認できる。
</p>

<pre>
$ gcc -v a.c
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/5/lto-wrapper
Target: x86_64-linux-gnu
Configured with: ../src/configure -v --with-pkgversion=&39;Ubuntu 5.4.0-6ubuntu1~16.04.9&39; --with-bugurl=file:///usr/share/doc/gcc-5/README.Bugs --enable-languages=c,ada,c++,java,go,d,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-5 --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --with-system-zlib --disable-browser-plugin --enable-java-awt=gtk --enable-gtk-cairo --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-5-amd64/jre --enable-java-home --with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-5-amd64 --with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-5-amd64 --with-arch-directory=amd64 --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --enable-objc-gc --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu
Thread model: posix
gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.9)
COLLECT_GCC_OPTIONS=&39;-v&39; &39;-mtune=generic&39; &39;-march=x86-64&39;
 /usr/lib/gcc/x86_64-linux-gnu/5/cc1 -quiet -v -imultiarch x86_64-linux-gnu a.c -quiet -dumpbase a.c -mtune=generic -march=x86-64 -auxbase a -version -fstack-protector-strong -Wformat -Wformat-security -o /tmp/cc8AbPic.s   <em> # cc1 を呼んでいる </em>
GNU C11 (Ubuntu 5.4.0-6ubuntu1~16.04.9) version 5.4.0 20160609 (x86_64-linux-gnu)
        compiled by GNU C version 5.4.0 20160609, GMP version 6.1.0, MPFR version 3.1.4, MPC version 1.0.3
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
ignoring nonexistent directory &quot;/usr/local/include/x86_64-linux-gnu&quot;
ignoring nonexistent directory &quot;/usr/lib/gcc/x86_64-linux-gnu/5/../../../../x86_64-linux-gnu/include&quot;
#include &quot;...&quot; search starts here:
#include &lt;...&gt; search starts here:
 /usr/lib/gcc/x86_64-linux-gnu/5/include
 /usr/local/include
 /usr/lib/gcc/x86_64-linux-gnu/5/include-fixed
 /usr/include/x86_64-linux-gnu
 /usr/include
End of search list.
GNU C11 (Ubuntu 5.4.0-6ubuntu1~16.04.9) version 5.4.0 20160609 (x86_64-linux-gnu)
        compiled by GNU C version 5.4.0 20160609, GMP version 6.1.0, MPFR version 3.1.4, MPC version 1.0.3
GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
Compiler executable checksum: d079eab342c322d6be59e8628e10ae67
COLLECT_GCC_OPTIONS=&39;-v&39; &39;-mtune=generic&39; &39;-march=x86-64&39;
 as -v --64 -o /tmp/ccNgb4Ka.o /tmp/cc8AbPic.s      <em> # as を呼んでいる </em>
GNU assembler version 2.26.1 (x86_64-linux-gnu) using BFD version (GNU Binutils for Ubuntu) 2.26.1
COMPILER_PATH=/usr/lib/gcc/x86_64-linux-gnu/5/:/usr/lib/gcc/x86_64-linux-gnu/5/:/usr/lib/gcc/x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/5/:/usr/lib/gcc/x86_64-linux-gnu/
LIBRARY_PATH=/usr/lib/gcc/x86_64-linux-gnu/5/:/usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/:/usr/lib/gcc/x86_64-linux-gnu/5/../../../../lib/:/lib/x86_64-linux-gnu/:/lib/../lib/:/usr/lib/x86_64-linux-gnu/:/usr/lib/../lib/:/usr/lib/gcc/x86_64-linux-gnu/5/../../../:/lib/:/usr/lib/
COLLECT_GCC_OPTIONS=&39;-v&39; &39;-mtune=generic&39; &39;-march=x86-64&39;
 /usr/lib/gcc/x86_64-linux-gnu/5/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/5/liblto_plugin.so -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/5/lto-wrapper -plugin-opt=-fresolution=/tmp/ccqaqkj9.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --sysroot=/ --build-id --eh-frame-hdr -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/5/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/5 -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../../lib -L/lib/x86_64-linux-gnu -L/lib/../lib -L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/5/../../.. /tmp/ccNgb4Ka.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/5/crtend.o /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crtn.o <em> # collect2 を呼んでいる </em>
</pre>

<p>
  cc1, as, collect2 コマンドが呼ばれていることを確認しよう。また、わかりにくいが、リンク時に、crtなんとか.o と、-lc -lgcc をリンクしていることも見ておいてほしい。
  crtなんとか.o がスタートアップルーチンを含むオブジェクト、-lc が libc、-lgcc が、libgcc だ。
</p>

<p>
  昔は、Cのプリプロセッサは独立したコマンドとして呼ばれていたが、今のCコンパイラは、Cプリプロセッサを内蔵しており、プリプロセスしながらコンパイルを行う。
  そのため、通常はプリプロセッサが単体で呼ばれることはない。(-E オプションを付けてgccを呼び出せば明示的にプリプロセスだけを実行させることはできる)
</p>

<p>
  cc1 は gcc の内部コマンドなので、シェルから呼び出すことはできない。上の -v の出力で出てきたcc1のパスを直接実行しよう。
</p>

<pre>
$ cat a.c
int main() { }
$ /usr/lib/gcc/x86_64-linux-gnu//5/cc1 a.c
 main
Analyzing compilation unit
Performing interprocedural optimizations
 &lt;*free_lang_data&gt; &lt;visibility&gt; &lt;build_ssa_passes&gt; &lt;opt_local_passes&gt; &lt;free-inline-summary&gt; &lt;whole-program&gt; &lt;inline&gt;Assembling functions:
 main
Execution times (seconds)
 phase setup             :   0.00 ( 0%) usr   0.00 ( 0%) sys   0.01 (50%) wall    1093 kB (85%) ggc
 phase finalize          :   0.00 ( 0%) usr   0.00 ( 0%) sys   0.01 (50%) wall       0 kB ( 0%) ggc
 TOTAL                 :   0.00             0.00             0.02               1286 kB
</pre>

<p>
  cc1 に a.c を渡すと、a.s というアセンブリファイルが出力されるており、cc1 が「Cソースをアセンブリに変換する」という教科書どおりのコンパイラの動作をしていることを確認しよう。
  cc1 は、内部コマンドなので、ユーザが直接使うことは想定されておらず、オプション等はGCCのバージョンによって大きく変わる。筆者もあんまり把握していないので、詳しい説明は省略する。
</p>

<p>
  as は Linux標準のアセンブラだ。アセンブリをオブジェクトコードに変換する。
  これまで書いてきたいくつかのアセンブリのソースを、as を使って変換してみよう。
</p>
<pre>
$ as main.s 
$ ls 
a.out  main.s
</pre>

<p>
  gcc -c で main.s をアセンブルした時は、main.o に出力してくれるが、as でアセンブルすると、指定しないと a.out というファイルになる。
  紛らわしいが、この a.out は実行できるファイルではない。
</p>

<p>
  as でアセンブルした場合と、 gcc で実行できるa.outを作った場合で、ファイルタイプが異なる。
  readelf -h は、オブジェクトファイルのヘッダ情報を出力するコマンドだ。
  これを見ると実行できるファイルかどうか判断できる。
</p>

<pre>
$ as main.s
$ readelf -h a.out
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)         <em> # Type が REL </em>
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          320 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         8
  Section header string table index: 5
$ gcc -no-pie main.s
$ readelf -h a.out
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)         <em> # Type が EXEC </em>
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x400430
  Start of program headers:          64 (bytes into file)
  Start of section headers:          6592 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         9
  Size of section headers:           64 (bytes)
  Number of section headers:         31
  Section header string table index: 28
</pre>

<p> これはどういうことなのか、というのが、このリンクの章で説明したいことだ。あとでじっくり説明するので、少々お待ちください。</p>

<p> a.out 以外のファイル名で出力する場合は、-o &lt;ファイル名&gt; オプションを使う。 </p>


<p>
  最後にld。ld は、Linux標準のリンカだ。リンカは、アセンブラが出力したオブジェクトをリンクし、実行ファイルや共有ライブラリを出力する。
</p>

<pre>
$ cat main.s
	.globl	main
main:
	ret
$ as main.s -o main.o
$ ld main.o -o a.out
/usr/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000400078
$ readelf -h a.out
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)          <em> 実行ファイル </em>
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x400078
  Start of program headers:          64 (bytes into file)
  Start of section headers:          360 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         1
  Size of section headers:           64 (bytes)
  Number of section headers:         5
  Section header string table index: 2
$ ./a.out
segmentation fault (core dumped)
</pre>

<p> ld を使って、main.o をリンクすると、今度は、きちんと実行できるファイルが出力されていることを確認しよう。 </p>

<p> しかし、この実行ファイルは、実行はできるものの、実行すると正常終了しない。</p>

<pre>
(gdb) b main
Breakpoint 1 at 0x400078
(gdb) start
Temporary breakpoint 2 at 0x400078
Starting program: /mnt/d/wsl/src/pllp/docs/link/x/a.out 

Breakpoint 1, 0x0000000000400078 in main ()
(gdb) x/4i $pc
=&gt; 0x400078 &lt;main&gt;:	retq   
   0x400079:	add    %al,(%rax)
   0x40007b:	add    %al,(%rax)
   0x40007d:	add    %al,(%rax)
(gdb) p $rsp
$1 = (void *) 0x7ffffffee4f0
(gdb) p *(void**) $rsp
$2 = (void *) 0x1
(gdb) stepi
0x0000000000000001 in ?? ()
(gdb) stepi
</pre>

<p> プログラムの最後に ret 命令を書いていたが、 rsp が指す先には、戻りアドレスは存在していない。(プログラムカウンタが1になっている点を確認しよう) </p>

<p> これは、スタートアップルーチンをリンクしていないためだ。 </p>

<p>
  スタートアップルーチンは、mainを呼んだあとにもいくらかの後処理をする。
  スタートアップルーチンを正しくリンクした場合、プログラムカウンタが main に来たときは、
  スタックにmainの後処理をするアドレスが積まれている。
  なので、gccコンパイラドライバを使ってリンクした場合には、main から単に ret するだけで、プログラムが正しく終了できる。
</p>

<p>
  mainのあとに必要な処理はいくつかあるが、一番重要なのは、OSに対してプログラムの終了を依頼することだ。
  詳細はシステムコールのところで説明するが、x86_64 では、rax レジスタに 60 を設定して、syscall 命令を実行すればよい。
</p>

<p> <a href="link/exit.s"> link/exit.s </a> </p>

<pre>
	.globl	main
main:
	mov	$60, %rax
	syscall
</pre>

<pre>
$ as exit.s -o exit.o
$ ld exit.o -o a.out
/usr/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000400078
$ ./a.out
</pre>

<p> プログラムが正しく終了した。 </p>

<p>
  "/usr/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000400078"
  が気になるので、これも説明しておこう。
</p>

<p>
  さきほど書いたように、コンパイラドライバ経由でリンクされたオブジェクトは、スタートアップルーチンで初期化をする。
  これはつまり、main の前にいくらかプログラムが動いているわけで、プログラムの本当の開始位置は、main ではないのだ。
</p>

<p>
  ld では、オプション無しでオブジェクトをリンクすると、mainではなく、"_start" ラベルが置かれた位置をプログラム開始位置とする、と決められている
  (興味がある人は、gdb で _start にブレークポイントを置いてプログラムを実行してみよう)。
  "cannot find entry symbol _start" というのは、この "_start" ラベルが見つからないという意味だ。
</p>

<p> プログラムの起動と終了を要約すると、以下のようになる。 </p>

<ol>
  <li> _start ラベルが置かれた位置からプログラムスタート </li>
  <li> スタートアップルーチンが初期化する </li>
  <li> スタートアップルーチンが main を call する </li>
  <li> main でユーザが書いたプログラムを処理 </li>
  <li> main から ret </li>
  <li> スタートアップルーチンに戻ってくる </li>
  <li> 終了処理 </li>
  <li> OS に終了依頼 </li>
</ol>

<p>
  通常、コンパイラドライバ経由でオブジェクトをリンクした場合、スタートアップルーチンがリンクされるが、
  今は、スタートアップルーチンをリンクしないで実行ファイルを作っているので、最初の _start が定義されてない。
  よって、"cannot find entry symbol _start"という警告が出るのだ。
</p>

<p>
  自分で _start を定義してスタートアップルーチンを書いてみよう。
  と、いってもやることは、1. mainを呼ぶ 2. mainが終わったら終了する の二個だけだ。
</p>

<p> <a href="link/start_exit.s"> link/start_exit.s </a> </p>

<pre>
	.globl	_start

_start:
	call	main
	mov	$60, %rax
	syscall

main:
	ret

</pre>

<pre>
$ as start_exit.s -o start_exit.o
$ ld start_exit.o -o a.out
$ ./a.out
</pre>

<p> これで警告も出ないし、正しく終了できる実行ファイルが作れた。 </p>

<p> 以上、コンパイラドライバの内容と、コンパイラドライバを使わないで、アセンブル、リンクを行う方法について簡単に説明した。 </p>

<p> 色々はしょって解説したのでわかりにくかったかもしれないが、
  コンパイラドライバは、環境やバージョンによって動作が変わるので、あんまり細かい挙動について理解する必要はなくて、
  「コンパイラ、アセンブラ、リンカを順番に呼び出しているんだな」程度に理解してもらえればよいと思う。
</p>

<p> ついでに小技を紹介しておこう。コンパイラドライバであるgccを実行するときに、-Wl,-Wa というオプションを使うと、背後で実行されるリンカやアセンブラに直接オプションを渡すことができる。
</p>

<p>
  例えば、よく使うのは、rpathを指定する場合で、 "-Wl,-rpath,/usr/local/lib" というオプションをgccに渡すと、リンカldに"-rpath" "/usr/local/lib" というオプションを渡してくれる。
  (rpathの説明は省略する。必要になったときに思い出してほしい)
</p>
  

<p> これでリンカを単体で使う方法を説明できたので、いよいよ次はリンカの説明に入っていこう。 </p>

  <h3> リンクとはなにか </h3>
  <p> リンカがやっていることは、主に</p>
  <ul>
    <li> オブジェクトをくっつけて一個にする </li>
    <li> ラベルへの参照を解決する </li>
  </ul>

  <p> の二点だ。</p>

<p> 次のふたつのファイルをリンクしてみよう。</p>

<p>
  <a href="link/link0.s"> link/link0.s </a>
</p>
<pre>
	.globl	_start
_start:
	ret

</pre>

<p>
  <a href="link/link1.s"> link/link1.s </a>
</p>

<pre>
	nop
</pre>

<pre>
$ as link0.s -o link0.o
$ as link1.s -o link1.o
$ ld link0.o link1.o
$ objdump -d a.out

a.out:     file format elf64-x86-64


Disassembly of section .text:

0000000000400078 &lt;_start&gt;:
  400078:	c3                   	retq   
  400079:	90                   	nop

</pre>

<p> link0.s の ret 命令と、link1.s の nop 命令が一個のa.outにまとめられていることを確認してほしい </p>

<p>
  リンカの挙動を決める仕様は存在していないが、世の中の大体のリンカは、引数に指定した順にオブジェクトを並べていく。
  引数のファイルの順序を変えると、並ぶ命令の順序も変わる。
</p>

<pre>
$ ld link1.o link0.o 
$ objdump -d a.out

a.out:     file format elf64-x86-64


Disassembly of section .text:

0000000000400078 &lt;_start-0x1&gt;:
  400078:	90                   	nop

0000000000400079 &lt;_start&gt;:
  400079:	c3                   	retq   
</pre>

<p> C++ のグローバル変数のコンストラクタの呼び出し順などは、この順序で決まる実装が多いので、覚えておくと何かの役に立つかもしれない。 </p>

<p>
  続いて、リンカの重要な仕事が、ラベル参照の解決だ。これまでにも簡単に解説してきたが、あらためて説明しておこう。
</p>

<p>
  アセンブリファイル中には、ラベルが置ける。プログラムに含まれる命令、データは、リンクが終わるまでアドレスが確定しないが、
  ラベルを使うことで、リンク後に決まるアドレスの値を確定前に参照することができる。
</p>

<p> <a href="link/link_label0.s"> link/link_label0.s </a> </p>
<pre>
	.globl	_start
_start:
	mov	$label0, %rax
</pre>

<p> <a href="link/link_label1.s"> link/link_label1.s </a> </p>
<pre>
	.globl	label0
label0:
	mov	$_start, %rax
</pre>

<pre>
$ as link_label0.s -o link_label0.o
$ as link_label1.s -o link_label1.o
$ objdump -d link_label0.o

link_label0.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
$ objdump -d link_label1.o

link_label1.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;label0&gt;:
   0:	48 c7 c0 00 00 00 00 	mov    $0x0,%rax
$ ld link_label0.o link_label1.o 
$ objdump -d a.out

a.out:     file format elf64-x86-64


Disassembly of section .text:

0000000000400078 &lt;_start&gt;:
  400078:	48 c7 c0 7f 00 40 00 	mov    $0x40007f,%rax

000000000040007f &lt;label0&gt;:
  40007f:	48 c7 c0 78 00 40 00 	mov    $0x400078,%rax
</pre>

<p>
  リンクすると、_start ラベルが置かれたアドレスが0x400078、label0 ラベルが置かれたアドレスが0x40007d と確定する。
  リンク前は 0 だった mov 命令のオペランドが、リンク後には確定されたラベルのアドレスに書き換わっている点を確認しよう。
  このように、オブジェクト内に含まれているラベルへの参照を、確定したアドレスに書きかえることを「解決する(resolve)」と言う。
</p>

<p> このラベルの解決をするためにアセンブラ、リンカが何をやっているかを見ていこう。</p>

  <h3> シンボル、リロケーション </h3>

<p> オブジェクトファイルには、機械語、データの他に、ラベルの解決に必要な情報が含まれている。
  <em>シンボル (symbol)</em> と <em>リロケーション(relocation)</em>だ。
</p>

<p>
  <em> シンボル </em> は、アドレスを識別する文字表現を保持しておく情報だ。
  アセンブリ言語で書かれたラベルは、このシンボルに変換されて、オブジェクトファイル内に保持される。
  また、デバッガやリンカの動作を助けるために、追加の情報が付けられることもある。
</p>

<h4> シンボル </h4>

<p>
  <em> シンボル </em> には <em> 定義済みシンボル (defined symbol) </em>、<em> 未定義シンボル (undefined symbol) </em> の二種類がある。
</p>

<p>
  <em> 定義済みシンボル </em> は、ラベル等を使ってファイル内に定義された実体が存在するシンボルだ。
  定義済みシンボルは、ファイル内で定義された位置のオフセットと、追加情報、文字列表現の情報を持つ。
</p>

<p>
  <em> 未定義シンボル </em> は、オブジェクトファイル中に実体が存在しないシンボルだ。
  未定義シンボルは、あとでリンクするときのために文字列と追加情報を持ち、定義済みシンボルと違って定義された位置のオフセットは持たない。
</p>

<p>
  このあたりの定義もかなり曖昧で、単にシンボルと言うときは、定義済みシンボルのことを指すことが多い。
  毎回"定義済みシンボル"と表記するのはあまり一般的ではないが、
  このリンカの章では、説明の曖昧さをなくすために、毎回"定義済みシンボル"と書くことにする。
  他の章では、慣習に従って、必要のないときは"定義済みシンボル"の意味で"シンボルと書くことにしよう。
</p>

<p>
  "ラベル" と "定義済みシンボル" は、かなり似たものになる。
  何が違うか…というのは…筆者もあまり把握していないが…
  アセンブリ言語などの、ソースコード中に目印として置かれるものは"ラベル"、
  オブジェクトに含まれている情報は"シンボル"、と呼ばれることが多いように思う。
</p>

<p>
  オブジェクト内に含まれる"定義済みシンボル"を"ラベル"と呼ぶことはあまりないので、その慣習にしたがって以下では、
  ソースコードに貼られた情報をラベル、オブジェクト内に含まれた情報を定義済みシンボルと呼ぶことにする。
  (あまり厳密な使いわけはされてないと思うので、呼び間違えても話は通じるはず)
</p>

<p>
  これまで何度か使ってきたreadelfに"-s"を付けて実行すると、オブジェクトに含まれる定義済みシンボル、未定義シンボルの情報を表示することができる。
</p>

<p> <a href="link/defsym.s"> link/defsym.s </a> </p>

<pre>
	.globl	_start
	.globl	sym0
_start:
	nop

sym0:
	nop
sym1:
	nop
	nop
	nop
	nop
sym2:
	nop

</pre>

<p>--</p>

<pre>
$ readelf -s defsym.o

Symbol table &39;.symtab&39; contains 8 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    2 
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 
     4: 0000000000000002     0 NOTYPE  LOCAL  DEFAULT    1 sym1
     5: 0000000000000006     0 NOTYPE  LOCAL  DEFAULT    1 sym2
     6: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT    1 _start
     7: 0000000000000001     0 NOTYPE  GLOBAL DEFAULT    1 sym0
</pre>

<pre>
$ objdump -d defsym.o 

defsym.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:	90                   	nop

0000000000000001 &lt;sym0&gt;:
   1:	90                   	nop

0000000000000002 &lt;sym1&gt;:
   2:	90                   	nop
   3:	90                   	nop
   4:	90                   	nop
   5:	90                   	nop

0000000000000006 &lt;sym2&gt;:
   6:	90                   	nop
</pre>

<p> sym0, sym1, sym2 というみっつのシンボルを定義しているプログラムだ。 </p>

<p> これのラベルをダンプすると、 </p>

<pre>
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     4: 0000000000000002     0 NOTYPE  LOCAL  DEFAULT    1 sym1
     5: 0000000000000006     0 NOTYPE  LOCAL  DEFAULT    1 sym2
     6: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT    1 _start
     7: 0000000000000001     0 NOTYPE  GLOBAL DEFAULT    1 sym0
</pre>

<p> このようになる。1-3 については、あとのセクションのところで詳しく書く。 0番は…筆者も何か知らない。 </p>

<p> Value のカラムで示される値が、ファイル内でのオフセットだ。sym0,sym1,sym2 のそれぞれのオフセット値を確認してほしい。 </p>

<p> 次にSizeとTypeカラム、シンボルは上のほうで書いたように、デバッグ時等にも使える情報を含んでいる。これもあとでもう少し詳しく説明しよう。 </p>

<p>
  次はBindとVisカラム。プログラムを書いたことのある人なら、「スコープ」の重要性は理解しているだろう。
  オブジェクトファイルにもこのスコープの概念があり、シンボルが見える範囲を制御することができる。
  オブジェクトファイルにもいくつかのスコープ階層がある。
</p>

<ul>
  <li> ローカルシンボル </li>
  <li> グローバルシンボル </li>
  <li> エクスポートシンボル </li>
</ul>

<p>
  ローカルシンボルは、ファイル内でのみ参照可能な定義済みシンボルだ。C言語のstaticが付いたグローバル変数、関数がこれに相当すると思ってもらってよい。
  グローバルシンボルは、逆にファイル外からも参照できる定義済みシンボルで、こちらはC言語でいうとstaticが付かないグローバル変数、関数が相当する。
</p>

<p>
  ローカルシンボルは、別のファイルからは参照できない。
</p>

<p> <a href="link/local_symbol0.s"> link/local_symbol0.s </a> </p>
<pre>
_start:
	mov	$local_symbol, %rax
	mov	$global_symbol, %rax
</pre>

<p> <a href="link/local_symbol1.s"> link/local_symbol1.s </a> </p>
<pre>
	.globl global_symbol

local_symbol:
	nop
global_symbol:
	nop
</pre>

<pre>
$ as local_symbol0.s -o local_symbol0.o
$ as local_symbol1.s -o local_symbol1.o
$ ld local_symbol0.o local_symbol1.o 
/usr/bin/ld: warning: cannot find entry symbol _start; defaulting to 0000000000400078
local_symbol0.o: In function `_start':
(.text+0x3): undefined reference to `local_symbol'
</pre>

<p>
  local_symbol が local_symbol1.s で定義されているが、定義されていないとエラーが出ていることを確認しよう。
</p>

<p>
  ついでに、_start 見つからないとエラーが出ているのを確認してほしい。
  これまでのアセンブリファイルでは、ファイルの最初に、
</p>

<pre>
  .globl _start
  .globl main
</pre>

<p> などと書いていたことを思い出そう。ようやくこれを説明するときがきた。 </p>

<p> .globl は、アセンブラに対して、指定した定義済みシンボルをグローバルシンボルにしろ、と指示する疑似命令だ。(.globalでもいい) </p>

<p>
  "main" シンボルは、スタートアップルーチンからファイルを超えて参照されるので、グローバルシンボルにしておく必要がある。
  そのため、これまでのアセンブリファイルには、".globl main" を書いていた。
</p>

<p>
  "_start" シンボルの扱いは、通常のシンボルとは少し違うが、
  リンク時の挙動として、「グローバルシンボルの"_start"をプログラムの開始位置とする」と決められている。
  オブジェクトを超えて外部から見えるように扱うので、グローバルシンボルとして扱うほうが自然だろう。
</p>

<p>
  次に、エクスポートシンボルだ。これは、DLL 等の共有ライブラリを作るときなどに使われるシンボルで、
  実行時にもファイルを超えて参照される定義済みシンボルだ。
</p>

<p>
  共有ライブラリを使う場合には、実行時にもファイルを超えて未定義シンボルと定義済みシンボルを結びつけるリンク処理が必要になり、
  そのための情報を残しておく必要がある。
  エクスポートシンボルはそのためのシンボルだ。
</p>

<p>
  Linux では、visibilityという属性(readelf -s で見られる Vis カラム)が、エクスポートシンボルかどうかに影響していて、
  リンク時にエクスポートシンボルを残すと指示した場合に、Vis が DEFAULT のシンボルがエクスポートシンボルになる。
</p>

<p>
  共有ライブラリについては、いくらか書くべきことが多いので、エクスポートシンボルの扱いについてはまたあとで別に書くとしよう。
</p>

<p> あとウィークシンボルというのもあるが、これはLinux(というかELF)固有の概念なので特にここでは書かない。興味がある人は各自で調べてほしい。 </p>

<p> あとc,c++に依存したシンボル属性もある。これはあとでC言語のところで説明しよう。</p>

<h4> リロケーション </h4>

<p>
  次に<em>リロケーション</em> だ。<em> リロケーション </em> は、アドレス解決後の値を埋め込む方法を保持する情報だ。
</p>

<p>
  readelfを使えばリロケーションの情報も見ることができる。"-r" で、リロケーション情報を表示だ。
</p>

<p> さきほどの <a href="link/link_label1.s"> link/link_label1.s </a> をアセンブルしたlink_label1.o を見てみよう。 </p>

<pre>
$ readelf -r link_label1.o

Relocation section &39;.rela.text&39; at offset 0xe8 contains 1 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000003  00050000000b R_X86_64_32S      0000000000000000 _start + 0
</pre>

<pre>
$ readelf -s link_label1.o

Symbol table &39;.symtab&39; contains 6 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 
     4: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT    1 label0
     5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _start
$
 </pre>

<p>
  詳しく見ていこう。
</p>

<p> <a href="link/reloc.s"> link/reloc.s </a> </p>
<pre>
	.globl	_start
_start:
	movl	$ref_32bit, %eax # 32bitラベルを参照
	movw	$ref_16bit, %ax	 # 16bitラベルを参照
	movb	$ref_8bit, %al   # 8bitラベルを参照
	jmp	ref_as_jmp_label # PC 相対アドレスを参照

	movl	$ref_32bit + 32, %eax # オフセット付き

	mov	$60, %rax
	syscall

</pre>


<p> <a href="link/reloc_label.s"> link/reloc_label.s </a> </p>
<pre>
	.text
	.globl ref_32bit
	.globl ref_16bit
	.globl ref_8bit
	.globl ref_as_jmp_label

	nop
ref_32bit:
	nop
ref_16bit:
	nop
ref_8bit:
	nop
ref_as_jmp_label:
	nop
</pre>

<p>--</p>


<pre>
$ readelf -r reloc.o 

Relocation section '.rela.text' at offset 0x170 contains 5 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000001  00050000000a R_X86_64_32       0000000000000000 ref_32bit + 0
000000000007  00060000000c R_X86_64_16       0000000000000000 ref_16bit + 0
00000000000a  00070000000e R_X86_64_8        0000000000000000 ref_8bit + 0
000000000011  00050000000a R_X86_64_32       0000000000000000 ref_32bit + 20
00000000000c  000800000002 R_X86_64_PC32     0000000000000000 ref_as_jmp_label - 4
</pre>

<pre>
$ objdump -d reloc.o                       # リンク前の逆アセンブル

reloc.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:	b8 00 00 00 00       	mov    $0x0,%eax
   5:	66 b8 00 00          	mov    $0x0,%ax
   9:	b0 00                	mov    $0x0,%al
   b:	e9 00 00 00 00       	jmpq   10 &lt;_start+0x10&gt;
  10:	b8 00 00 00 00       	mov    $0x0,%eax
  15:	48 c7 c0 3c 00 00 00 	mov    $0x3c,%rax
  1c:	0f 05                	syscall 
</pre>

<pre>
$ objdump -dr reloc.o                       # -dr でリロケーションと逆アセンブルを同時に表示

reloc.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:	b8 00 00 00 00       	mov    $0x0,%eax
			1: R_X86_64_32	ref_32bit
   5:	66 b8 00 00          	mov    $0x0,%ax
			7: R_X86_64_16	ref_16bit
   9:	b0 00                	mov    $0x0,%al
			a: R_X86_64_8	ref_8bit
   b:	e9 00 00 00 00       	jmpq   10 &lt;_start+0x10&gt;
			c: R_X86_64_PC32	ref_as_jmp_label-0x4
  10:	b8 00 00 00 00       	mov    $0x0,%eax
			11: R_X86_64_32	ref_32bit+0x20
  15:	48 c7 c0 3c 00 00 00 	mov    $0x3c,%rax
  1c:	0f 05                	syscall 
</pre>


<pre>
$ ld  reloc.o reloc_label.o -Ttext=0x0     # ラベルの配置アドレスを8bit以内にするためtextの位置を0にしておく
$ objdump  -d a.out                        # リンク後の逆アセンブル

a.out:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:	b8 1f 00 00 00       	mov    $0x1f,%eax
   5:	66 b8 20 00          	mov    $0x20,%ax
   9:	b0 21                	mov    $0x21,%al
   b:	e9 12 00 00 00       	jmpq   22 &lt;ref_as_jmp_label&gt;
  10:	b8 3f 00 00 00       	mov    $0x3f,%eax
  15:	48 c7 c0 3c 00 00 00 	mov    $0x3c,%rax
  1c:	0f 05                	syscall 
  1e:	90                   	nop

000000000000001f &lt;ref_32bit&gt;:
  1f:	90                   	nop

0000000000000020 &lt;ref_16bit&gt;:
  20:	90                   	nop

0000000000000021 &lt;ref_8bit&gt;:
  21:	90                   	nop

0000000000000022 &lt;ref_as_jmp_label&gt;:
  22:	90                   	nop
</pre>

<p>--</p>

<pre>
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000001  00050000000a R_X86_64_32       0000000000000000 ref_32bit + 0
</pre>

<p>
  まず、Offset、これは解決した値を埋める位置を示している。最初の mov 命令の32bitオペランドの位置が、
  先頭から1byteのところにあるのを確認しよう。
  これが1byteなので、Offsetは1だ。
</pre>

<pre>
#リンク前
           v ここ(offset=1byte)に解決した32bit値を入れる
   0:	b8 00 00 00 00       	mov    $0x0,%eax

#リンク後
   0:	b8 1f 00 00 00       	mov    $0x1f,%eax
</pre>

<p>
  次に、Info と Type。x86_64 では、 Info の下32bitが Type になり、Type のカラムは、この32bit値を読みやすい形で表示しているだけだ。
  Info の下32bit が、0x0000000a の場合、Type が R_X86_64_32 になる。
</p>

<p>
  Type の解釈方法は、CPUによって異なる。x86_64 の場合は、<a href="https://www.uclibc.org/docs/psABI-x86_64.pdf"> AMD64 ABI </a> に書かれている。
  まあ筆者もこれはちゃんと読んだことはなくて、自分でリンカを作るとかでなければ、/usr/include/elf.h にある定義を見ればよいと思う。
</p>

<p>
  reloc.o に含まれるリロケーションの Type には色々あるのを確認してほしい。シンボルの参照方法は、一種類ではなく、複数ある。
</p>

<pre>
	movl	$ref_32bit, %eax # 32bitラベルを参照
	movw	$ref_16bit, %ax	 # 16bitラベルを参照
</pre>

<ul>
  <li> movl のほうは、ラベル解決後の値を32bit値として、命令のオペランドに埋めてほしい </li>
  <li> movw のほうは、ラベル解決後の値を16bit値として、命令のオペランドに埋めてほしい </li>
</ul>

<p> このふたつでは、命令中のオペランドの書き換えかたが変わるはずだ。ここで、「どうやってオペランドを書き換えるか」を示すのが、リロケーションのTypeだ。</p>

<pre>
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000001  00050000000a R_X86_64_32       0000000000000000 ref_32bit + 0
000000000007  00060000000c R_X86_64_16       0000000000000000 ref_16bit + 0
</pre>

<p> offset=0000000000000001 の 32bit mov のオペランドのリロケーションと、offset=0000000000000007 の 16bit mov のオペランドのリロケーションで Type が違う点、解決後の値の埋めかたが変わっている点を確認してほしい。 </p>


<pre>
#asm
	movl	$ref_32bit, %eax # 32bitラベルを参照
	movw	$ref_16bit, %ax	 # 16bitラベルを参照

#リンク前
   0:	b8 00 00 00 00       	mov    $0x0,%eax
   5:	66 b8 00 00          	mov    $0x0,%ax

#リンク後
   0:	b8 1f 00 00 00       	mov    $0x1f,%eax   # ラベル ref_32bit を解決した値 1f を 32bit値として入れる
   5:	66 b8 20 00          	mov    $0x20,%ax    # ラベル ref_16bit を解決した値 20 を 16bit値として入れる
</pre>

<p>
  このように、リロケーションの指示に応じて、適切なリンク後の値をオブジェクトに入れる処理を<em>リロケーション(relocation)</em>と呼ぶ。
  これはタイポではないと信じている。リロケーションを置換する処理をリロケーションと呼ぶのが一般的なはずだ。
</p>

<p> また、同じサイズのリロケーションでもTypeが異なる場合がある。 </p>

<pre>
	movl	$ref_32bit, %eax # 32bitラベルを参照
	jmp	ref_as_jmp_label # PC 相対アドレスを参照
</pre>

<pre>
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000001  00050000000a R_X86_64_32       0000000000000000 ref_32bit + 0
00000000000c  000800000002 R_X86_64_PC32     0000000000000000 ref_as_jmp_label - 4
</pre>

<p>
  x86_64 機械語では、分岐命令のアドレスは、分岐命令の直後のアドレスからの相対値になる。
  上の jmp 命令で、ref_as_jmp_label ラベルが、解決されたあと、その値がそのまま埋められると、jmp 命令は正しく機能しない。
  リンカは、ref_as_jmp_label の解決後、jmp 命令の次の命令が置かれたアドレスとの相対値を埋める必要がある。
</p>

<pre>
# asm
	jmp	ref_as_jmp_label # PC 相対アドレスを参照

# リンク前
   b:	e9 00 00 00 00       	jmpq   10 &lt;_start+0x10&gt;

# リンク後
   b:	e9 12 00 00 00       	jmpq   22 &lt;ref_as_jmp_label&gt;
  10:	b8 3f 00 00 00       	mov    $0x3f,%eax
   (.. 略 ..)
0000000000000022 &lt;ref_as_jmp_label&gt;:
  22:	90                   	nop

</pre>

<p>
  jmp 命令の次の命令のアドレスが0x10、
  ref_as_jmp_label の解決後の値が 0x22、その差は  +0x12 となって、jmp 命令のオペランドには +0x12 が埋められることを確認してほしい。
</p>

<p> 最後に Addend だ。 </p>

<p> リロケーションは、参照するシンボルから何byte離れているかのオフセットを持つことができる。 </p>

<pre>
	movl	$ref_32bit + 32, %eax # オフセット付き
</pre>

<p>
  この命令の場合、$ref_32bit の値は、リンク後に決まるが、即値movl 命令には加算機能が無いので、
  この +32 は、アセンブル時にも実行時にも計算することはできない。
  しかし、実際にはこれは正しく意図したとおりに動作するはずだ。この +32 はリンカが計算している。
</p>

<p>
  アセンブラは、アセンブル時に、ラベル + 定数となっている値は、あとでリンカが計算できるように、「ラベル + 定数」という情報をそのまま
  リロケーションの中にエンコードする。
</p>

<pre>
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000011  00050000000a R_X86_64_32       0000000000000000 ref_32bit + 20
</pre>

<p> readelf -r を見ると、ref_32bit + 20 (10進で32) と、そのままの形で情報が保存されているのが確認できるはずだ。 </p>

<p> 最後に、リロケーションのサイズについて。</p>
<p>リロケーションする値が、リロケーションの型のサイズを上回っていた場合、リンク時にエラーになる。</p>

<pre>
$ as reloc_label.s -o reloc_label.o 
$ as reloc.s -o reloc.o 
$ ld  reloc.o reloc_label.o -Ttext=0x100     # ラベルの配置アドレスを8bitを超えるようにする。
reloc.o: In function `_start':
(.text+0xa): relocation truncated to fit: R_X86_64_8 against symbol `ref_8bit' defined in .text section in reloc_label.o
</pre>

<p> ref_8bit の値が、R_X86_64_8 (8bit) に収めるために、切り捨てられたというエラーメッセージが出るはずだ。</p>

<p> C 言語でも似たようなエラーを見たことがある人がいるかもしれない。 </p>

<p> <a href="link/large0.c"> link/large0.c </a> </p>
<pre>
#include &lt;stdio.h&gt;
extern int a[];
extern int b[];

int main()
{
    printf(&quot;%d %d\n&quot;, a[0], b[0]);
}
</pre>

<p> <a href="link/large1.c"> link/large1.c </a> </p>
<pre>
int a[1024*1024*1024*4ULL];
int b[1024*1024*1024*4ULL];
</pre>

<p> ぱっと思い付くのは、32bit の範囲を超えるサイズの配列を定義した場合だ。 </p>

<pre>
$ gcc large0.c large1.c
/tmp/ccOwnkuE.o: In function `main&39;:
large0.c:(.text+0xc): relocation truncated to fit: R_X86_64_PC32 against symbol `a&39; defined in COMMON section in /tmp/cclJzRGJ.o
collect2: error: ld returned 1 exit status
</pre>

<p>
  x86_64 の gcc は、特に指定しない場合、配列の参照に 32bit リロケーションを使うので、配列サイズが32bitを超えてしまうと、
  リンクに失敗するようになる。
</p>

<p> 対処法としては、gcc に -mcmodel=large を付けると、配列の参照時のリロケーションに、64bit リロケーションを使ってくれるようになる。 </p>

<pre>
$ gcc -mcmodel=large large0.c large1.c
$ ./a.out 
0 0
</pre>

<h4> リンク手順のまとめ </h4>

<p> 色々と書いたので、少しまとめておこう。ここを読んでよくわからなければ、もう一度この章を最初から読んでいってほしい。 </p>

<p> (TODO:図を入れる) </p>

<p> 1. アセンブラが、ラベル位置、ラベル文字列、ラベル参照を適切なシンボル、リロケーションにエンコードしてオブジェクトに入れる </p>
<p> 2. リンカは、起動されると渡されたオブジェクトを順に並べていく </p>
<p> 3. オブジェクトを並べると定義済みシンボルの最終的な位置が確定する </p>
<p> 4. 確定した定義済みシンボルの値をリロケーションに埋めていく </p>

<h3> デバッグとシンボル </h3>

<p>
  シンボル情報はDLLを使わない場合、実行時には必要の無い情報だが、
  デバッグ時や、その他問題の対応時に人間にとっていくらか有用な場合があることを覚えておこう。
</p>

<p>
  これまで何度か gdb を使ってプログラムを動かしてきたと思うが、そのときに、数字のアドレスではなく、
  文字列としてのシンボルを扱えていたことを思い出してほしい。
  例えば、"break _start" などとすると、_startシンボルを解決した後のアドレスにブレークポイントを設定できていたはずだ。
</p>

<p>
  デバッガは、デバッグ情報が存在しなかった場合でも、
  残っているシンボル情報から、なるべくアドレスがわかりやすい値になるように
  最善を尽くす努力をしていて、
</p>

<ul>
  <li> アドレスを表示する場合には、そのアドレス付近に存在するシンボルから、一番それっぽいのを探して表示する </li>
  <li> ユーザがシンボル文字列を入力した場合には、そのシンボルと対応するアドレス値をうまいこと扱う </p>
</ul>

<p> というような挙動をする。 </p>
<p> 一番最初に info registers と打ったときの結果を思い出してほしい。 </p>

<pre>
(gdb) start
Temporary breakpoint 1 at 0x4004d6
Starting program: /mnt/d/wsl/src/pllp/docs/x8664_asm_language/a.out 

Temporary breakpoint 1, 0x00000000004004d6 in main ()
(gdb) info registers
rax            0x4004d6	4195542
rbx            0x0	0
rcx            0x0	0
rdx            0x7ffffffee518	140737488282904
rsi            0x7ffffffee508	140737488282888
rdi            0x1	1
rbp            0x4004e0	0x4004e0 &lt;__libc_csu_init&gt;
rsp            0x7ffffffee428	0x7ffffffee428
r8             0x400550	4195664
r9             0x7fffff410ab0	140737475840688
r10            0x846	2118
r11            0x7fffff050740	140737471907648
r12            0x4003e0	4195296
r13            0x7ffffffee500	140737488282880
r14            0x0	0
r15            0x0	0
rip            0x4004d6	0x4004d6 &lt;main&gt;
eflags         0x246	[ PF ZF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0

</pre>

<p>
  rbp の値に __libc_csu_init という文字列が付いているのがわかるだろう。
  これが gdb が rbp に残っていた値から探してきたシンボルの文字列だ。
</p>

<p>
  __libc_csu_init は、名前からして、libc の C Start Up の init だという推測ができる。
  main に来る前のスタートアップの初期化処理で rbp レジスタに何か値を入れていたのが残っていたのだろう。
</p>

<ul>
  <li> デバッガは値と紐付いたシンボル文字列を探してくるように努力する </li>
  <li> main に来る前にはスタートアップ処理が入る </li>
</ul>

<p>
  という二点を知っておけば、main に来た直後にデバッガで全レジスタを表示したら、スタートアップ処理に関連するシンボルが表示される可能性が高いという
  のは推測できるようになって、この表示は不思議な表示ではなくなったはずだ。
</p>

<p>
  シンボル情報は、実行時には必要ないものもあるので、実行ファイルから消すことものできる。
  Linux環境では、strip -s するとシンボル情報を消すことが可能だ。
</p>

<pre>
$ gcc -static main.s
$ readelf -s a.out

Symbol table '.symtab' contains 1803 entries:
   番号:      値         サイズ タイプ  Bind   Vis      索引名
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
(.. 略 ..)
  1802: 00000000004100d0   279 FUNC    WEAK   DEFAULT    6 fopen64


$ strip -s a.out
$ readelf -s a.out
$ # 何も表示されない
$
$ gdb a.out
GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from a.out...(no debugging symbols found)...done.
(gdb) start
No symbol table loaded.  Use the "file" command.
 
</pre>

<p>
  strip -s すると、readelf -s しても何も表示されなくなっていることを確認しよう。
</p>

<p>
  また、gdb の start コマンドも使えなくなっていることも確認してほしい。
</p>

<p>
  gdb の start コマンドは、定義済みシンボル "main" のあるアドレスにブレークポイントを設定するが、
  strip -s してしまうと、定義済みシンボル "main" に関する情報は削除されてしまうので、
  start コマンドは使えなくなってしまう。
</p>

<p>
  また、これまで gdb で disassemble コマンドを実行したときに、
  main に書いた覚えのない命令が付いているのに気付いた人もいるかもしれない。
</p>

<pre>
$ gcc main.s
$ gcc -static main.s
$ gdb a.out
GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from a.out...(no debugging symbols found)...done.
(gdb) start
Temporary breakpoint 1 at 0x400b4d
Starting program: /home/w0/src/pllp/docs/link/a.out 

Temporary breakpoint 1, 0x0000000000400b4d in main ()
(gdb) disassemble
Dump of assembler code for function main:
=&gt; 0x0000000000400b4d &lt;+0&gt;:	retq   
   0x0000000000400b4e &lt;+1&gt;:	xchg   %ax,%ax   # この xchg は自分で書いたものではない
End of assembler dump.
(gdb) 
</pre>

<p>
  main の ret のあとに、自分で書いたことのないxchgが付いているのを確認しよう。(環境によっては状況が変わるかもしれない)
</p>

<p>
  定義済みシンボルは、あくまで単一のアドレスを指すだけなので、
  mainシンボルが置かれた位置を記録できるが、mainに含まれる命令群の終わりは記録されていない。
</p>

<p>
  disassemble というコマンドは、指定された関数に含まれる命令列を表示するコマンドだが、
  gdbから見た場合、関数の先頭アドレスしかわからないのだ。
  そのため、disassemble は、次の定義済みシンボルまでの領域を関数と推測して、それを表示している。
</p>

<pre>
(gdb) x/4i main
   0x400b4d &lt;main&gt;:	retq   
   0x400b4e &lt;main+1&gt;:	xchg   %ax,%ax
   0x400b50 &lt;get_common_indeces.constprop.1&gt;:	push   %rbx
   0x400b51 &lt;get_common_indeces.constprop.1+1&gt;:	sub    $0x88,%rsp
</pre>

<p> 
  x コマンドなどで命令列を表示すれば、次の命令に定義済みシンボルが起かれていることを確認できるはずだ。
  (これも環境によって変わる場合があるので、別の表示になっているかもしれない)
</p>

<p>
  幸い、Linuxで採用されているELFでは、定義済みシンボルに、サイズとシンボルの種類を与えることができる。
</p>

<p> <a href="link/main_with_size.s"> link/main_with_size.s </a> </p>
<pre>
	.globl	main
main:
	ret
	.size	main, 1            # main のサイズ = 1byte
	.type	main, @function    # main は FUNC
</pre>

<pre>
$ gcc main_with_size.s
$ LANG=C readelf -s a.out | grep '\(Size\)\|\( main\)'
   Num:    Value          Size Type    Bind   Vis      Ndx Name
   Num:    Value          Size Type    Bind   Vis      Ndx Name
    55: 00000000000005fa     1 FUNC    GLOBAL DEFAULT   13 main
$ gdb a.out
GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
&lt;http://www.gnu.org/software/gdb/documentation/&gt;.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from a.out...(no debugging symbols found)...done.
(gdb) disassemble main
Dump of assembler code for function main:
   0x00000000000005fa &lt;+0&gt;:	retq   
End of assembler dump.
</pre>

<p>
  readelf で見て、Size が 1 になっており、
  disassemble の結果が正しく1byte分の命令だけ表示されていることを確認しよう。
  (シンボルのタイプをFUNCにする効果は筆者もよく知らない)
</p>

<p>
  シンボルに関する情報は、このようにプログラムを解析する場合にも活用できることが
  ご理解いただけただろうか。
</p>

<p>
  ただ、現実的には、自分でプログラムをビルドした時には、より強力な<em>デバッグ情報</em>を
  活用してデバッグをすることが多いだろう。
</p>

<p>
  デバッガを使ったことがある人なら、実行中の関数のローカル変数の状態を表示したりしたことがあるはずだ。
  これらを表示するために必要な情報はシンボル情報には含まれておらず、
  別途デバッグ情報と呼ばれる情報を付加してビルドする必要がある。
</p>

<p>
  デバッグ情報については、またあとのデバッガの章で詳しく解説することにしよう。
</p>

<p>
  この節では、デバッグ情報が無くてもデバッガは残された情報を
  努力して表示しているということを説明したかった。
  このデバッガの努力は、他人がビルドしてデバッグ情報が手に入らないようなプログラムを
  解析するぐらい追い詰められた時に役立ってくれるはずだ。
</p>

  <h3> セクション </h3>

<p>
  現代の多くのコンピュータでは、プログラムもデータもメモリに置かれたビット列であって、
  そのビット列の解釈の方法に違いがあるだけで、保存された情報に本質的な区別はない。
</p>

<p>
  それでも、ビット列の使いかたにあわせて、
  ビット列を分類してまとめておくと、有用な場合がある。
</p>

<p>
  わかりやすいのは、読み書きするビット列と読み込み専用ビット列の区別だ。
</p>

<p>
  本当に小さな組み込み機器に入っているコンピュータには、
  書き換え可能なRAMはほんの数KBぐらいしかなく、
  それに少し大きめのマスクROMが付いている、というものが多く存在する。
</p>

<p>
  そのようなコンピュータでメモリを効率良く使用するには、プログラムで使うビット列を、
</p>

<ul>
  <li> 読み書きするビット列はRAMに置く </li>
  <li> 読み込み専用ビット列はROMに置く </li>
</ul>

<p> というように使い分けて、小さなRAMに乗るデータは必要最低限にしたほうがいい。 </p>

<p>
  また、一部のマイナーなコンピュータでは、データ用のメモリと、プログラム用のメモリが
  完全に別れているものもあるが、そういう場合は、
  プログラムとして使われるビット列だけを別にまとめておかないと、
  正しく動くプログラムが出力できない。
</p>

<p>
  このようなことを実現するために、
  オブジェクトファイルは、ビット列を分類する機能を持っている。
  この分類を、<em>セクション(section)</em>と呼ぶ。
</p>

<p> 多くの環境で使われているセクションは、次のよっつだ </p>

<ul>
  <li> text : プログラムのビット列を入れるセクション </li>
  <li> data : 読み書きするビット列を入れるセクション </li>
  <li> rodata : 読み込み専用のビット列を入れるセクション </li>
  <li> bss : 読み書きするビット列のうち、初期値がゼロのものを入れるセクション </li>
</ul>

<p>
  (data,rodata はともかく、text,bss という名前は意味不明だが、
  これは多くの環境で採用されている名前なので、
  深く考えないでそういうものだと覚えるしかない。)
</p>

<p>
  bss は data とほぼ同じだが、 bss が data とは別に用意されている理由について説明をしておこう。
</p>

<p>
  実際のプログラムでは、読み書きされるビット列には、プログラム開始時には初期値が必要ないものが多い。
  この初期値の必要ないビット列を保存する領域は、オブジェクトファイル内にビット列を保存する必要がなく、
  領域のサイズだけを保存しておけば十分だ。
</p>

<p>
  そこで、初期値のない領域については、オブジェクトファイル内にビット列を保存するのではなく、
  かわりに、領域のサイズだけを記録しておく。
  そうすれば、オブジェクトファイルのサイズを減らすことができる。
</p>

<p>
  PCでは実行ファイルのサイズは大きな問題ではないが、ROM領域の限られた小さいマシンでは、
  実行ファイルのサイズが小さくなれば助かることも多い。
  そのため、初期値の必要ないデータは、初期値ありの読み書きするデータとは区別しておくのだ。
</p>

<p>
  (TODO:適切な図を入れる)
</p>


<p>
  実際の環境では、この標準的なよっつのセクション(text,data,rodata,bss)に加えて、
  環境依存のセクションがいくつかある。それについてはまた必要になったときに説明しよう。
</p>




<p>
  アセンブリ言語には、内で指定されたビット列(命令、データ)をどのセクションに配置するか
  を指示する疑似命令があり、アセンブラは、これに従って、プログラマに指示された通りにビット列を
  適切なセクションに配置していく。
</p>

<p> <a href="link/main.s"> link/section.s </a> </p>

<pre>
	.text
	ret

	.section .rodata
	ret

	.data
	ret
</pre>

<p> 
  このアセンブリは、3つのret命令 (0xc3) を、.text, .rodata, .data セクションに配置する。
</p>

<p>
  ".section" 疑似命令は、以下に続く命令、データを配置するセクションを指定するための疑似命令だ。".section &lt;名前&gt;" と書くと、指定した名前のセクションに命令、データを配置できる。

  ".text", ".data" は…なんで存在するんでしょうねぇ…(よく知らない)

</p>

<p>
  これをアセンブルし、中身を見てみよう。
</p>

<pre>
$ as sectioin.s -o section.o
$ objdump -d section.o

a.out:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <.text>:
   0:   c3                      retq  
</pre>

<p>
  一個のretqが表示されている。
</p>

<p>
  objdump は、-d を指定すると、.textセクションに含まれる機械語を逆アセンブルして表示する。
</p>

<p>
  機械語のところで説明したとおり、機械語というのは、ただのバイト列で、それを見ただけではデータかプログラムかを判別することができない。
  objdump は、含まれるデータがプログラムかデータかを判別するのにセクション名(か…属性か…どっちか)を使っている。(あとで調べる)
  そのため、.rodata や .data に含まれる 0xc3 というバイト列はデータとみなされて逆アセンブルされない。
</p>

<p> .rodata や .data を含む全てのバイト列を逆アセンブルする場合は、 "-D" オプションを使う </p>

<pre>
$ objdump -D a.out

a.out:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <.text>:
   0:   c3                      retq

Disassembly of section .data:

0000000000000000 <.data>:
   0:   c3                      retq

Disassembly of section .rodata:

0000000000000000 <.rodata>:
   0:   c3                      retq  
</pre>

<p> 全てのセクションに含まれる 0xc3 が逆アセンブルされていることを確認しよう。 </p>


<p> そういえばセクションの属性ってどこで決まるんや…？名前…？ </p>

<p class="kokomade"> (ここまで書いた )</p>



<p>
  リンカは、与えられたオブジェクトファイルに含まれるビット列を結合するときに、
  セクションごとにまとめて、アドレスを与えて結合していく。
</p>


<p> 途中なんだけど何を書くつもりだったか思い出せない… </p>

  <h3> 実行ファイル、セグメント </h3>

  <h3> ELF </h3>

<p> ここまで、シンボル、リロケーション、セクション、セグメント について説明してきた。 </p>

<p> GNU/Linux 環境では、これらの情報は、<em>ELF (Executable Loadable Format)</em> というフォーマットを持つオブジェクトファイルの中に保存される。 </p>

<p>
  ELFの構造を覚えておけば、アセンブラ、リンカが何をやってるかというのがより具体的に
  イメージできるようになるだろう。
</p>

<p>
  また、ELFファイルを読むプログラムをぱっと書けるようになれば、
  まあ色々な場面で役立つことがあるはずだ。
  筆者もELFファイルをロードするプログラムを書いて救われた場面が何度かある。
</p>

<h4> elf.h </h4>

<p>
  ELF ファイルを読むために必要な構造体などは、elf.h というヘッダに含まれている。
  elf.h は、glibc のヘッダの一部としてインストールされるようなので、
  Linux上でC言語が使える環境なら、通常はあわせてインストールされているはずだ。
</p>

<p>
  man elf を見れば、このelf.hに含まれている定義の説明も確認できるだろう。
</p>

<p>
  一旦構造を理解すれば、あとはこの elf.h と man elf を見れば
  ELFを読み書きするプログラムが書けるようになるはずだ。
</p>

<h4> </h4>

  <h3> ldscript </h3>

  <h3> ローダ </h3>

  <h3> PE/COFF </h3>

<p>
  オブジェクトファイルのフォーマットは、OS ごとに異なるが、
  リロケーション、シンボル、セクションといった概念は、どのオブジェクトでも大きく変わることはない。
  ここでは、Windowsで使われているCOFFについて簡単に説明する。
  これまで見てきた概念は、特定の実装に依存せず広く利用されているのを確認してほしい。
</p>

<p> (ちなみに、OSXでは、Mach-O というまた別のフォーマットが採用されている。筆者はあまり詳しくないので、OSXユーザは各自で調べてください) </p>

<p>
  Microsoft の開発環境をインストールして cl.exe などのツールが動くようにしてほしい。
  cl.exe が動くようになっていれば、dumpbin.exe というコマンドも使えるようになっているはずだ。
  dumpbin.exe は、readelf のようにオブジェクトの内容を表示するコマンドがある。これで色々見ていってみよう。
</p>



<p> <a href="index.html"> 戻る </a> </p>



</body>
</html>